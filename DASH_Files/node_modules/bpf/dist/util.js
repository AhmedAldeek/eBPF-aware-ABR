"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkU32 = exports.sliceBuffer = exports.asFloat64Array = exports.asFloat32Array = exports.asBigUint64Array = exports.asUint32Array = exports.asUint16Array = exports.asUint8Array = exports.asBigInt64Array = exports.asInt32Array = exports.asInt16Array = exports.asInt8Array = exports.asBuffer = exports.version = exports.versions = exports.native = void 0;
exports.native = require('node-gyp-build')(__dirname + '/..');
exports.versions = exports.native.versions;
/** alias of `versions.libbpf` */
exports.version = exports.versions.libbpf;
exports.asBuffer = (x, length = x.byteLength / Buffer.BYTES_PER_ELEMENT, byteOffset = 0) => Buffer.from(x.buffer, x.byteOffset + byteOffset, length);
exports.asInt8Array = (x, length = x.byteLength / Int8Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Int8Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asInt16Array = (x, length = x.byteLength / Int16Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Int16Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asInt32Array = (x, length = x.byteLength / Int32Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Int32Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asBigInt64Array = (x, length = x.byteLength / BigInt64Array.BYTES_PER_ELEMENT, byteOffset = 0) => new BigInt64Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asUint8Array = (x, length = x.byteLength / Uint8Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Uint8Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asUint16Array = (x, length = x.byteLength / Uint16Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Uint16Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asUint32Array = (x, length = x.byteLength / Uint32Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Uint32Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asBigUint64Array = (x, length = x.byteLength / BigUint64Array.BYTES_PER_ELEMENT, byteOffset = 0) => new BigUint64Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asFloat32Array = (x, length = x.byteLength / Float32Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Float32Array(x.buffer, x.byteOffset + byteOffset, length);
exports.asFloat64Array = (x, length = x.byteLength / Float64Array.BYTES_PER_ELEMENT, byteOffset = 0) => new Float64Array(x.buffer, x.byteOffset + byteOffset, length);
// Other
function sliceBuffer(x, count, size) {
    const ret = [];
    for (let i = 0; i < count; i++)
        ret.push(x.subarray(i * size, (i + 1) * size));
    return ret;
}
exports.sliceBuffer = sliceBuffer;
function checkU32(x) {
    if (x !== (x >>> 0))
        throw new RangeError(`${x} is not a valid u32`);
    return x;
}
exports.checkU32 = checkU32;
//# sourceMappingURL=util.js.map