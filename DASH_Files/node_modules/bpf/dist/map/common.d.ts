/// <reference types="node" />
import { FD } from '../util';
import { MapType } from '../constants';
export interface MapDefOptional {
    /** Flags specified on map creation, see [[MapFlags]] */
    flags?: number;
    /** Map name (might get truncated if longer than [[OBJ_NAME_LEN]]) (since Linux 4.15) */
    name?: string;
    /** NUMA node on which to store the map (since Linux 4.15) */
    numaNode?: number;
    /**
     * For map-in-map types: parameters for the inner map,
     * or FD of an existing map to clone parameters from.
     * The passed map's lifetime isn't affected in any way.
     */
    innerMap?: MapDef | MapRef | number;
    /** For offloading, ifindex of network device to create the map on (since Linux 4.16) */
    ifindex?: number;
}
/**
 * Parameters to create an eBPF map.
 *
 * After the map is created, the parameters may be different
 * because of rounding, truncating or type-dependent behaviour.
 */
export interface MapDef extends MapDefOptional {
    /**
     * Map type. This decides the available operations and
     * their semantics. Keep in mind that not all of the types
     * may be supported by your kernel.
     */
    type: MapType;
    /** Size of every key, in bytes */
    keySize: number;
    /** Size of every value, in bytes */
    valueSize: number;
    /** Maximum amount of entries: the meaning of this is type-dependent */
    maxEntries: number;
}
/**
 * Information reported about an eBPF map.
 *
 * After the map is created, the parameters may be different
 * because of rounding, truncating or type-dependent behaviour.
 *
 * Optional parameters are present if the running kernel version
 * supports them.
 */
export interface MapInfo {
    /**
     * Map type. This decides the available operations and
     * their semantics.
     */
    type: MapType;
    /** Map ID (since Linux 4.13) */
    id?: number;
    /** Size of every key, in bytes */
    keySize: number;
    /** Size of every value, in bytes */
    valueSize: number;
    /** Maximum amount of entries: the meaning of this is type-dependent */
    maxEntries: number;
    /** Flags specified on map creation, see [[MapFlags]] */
    flags: number;
    /** Map name (might get truncated if longer than [[OBJ_NAME_LEN]]) (since Linux 4.15) */
    name?: string;
    /** For offloading, ifindex of network device the map was created on (reported since Linux 4.16) */
    ifindex?: number;
    netnsDev?: bigint;
    netnsIno?: bigint;
}
/**
 * Object holdling a file descriptor (plus parameters) for an
 * eBPF map. The object must own the file descriptor, meaning
 * that it won't get closed while this object is alive.
 *
 * If you got a file descriptor from someplace else, you can
 * use [[createMapRef]] to obtain a [[MapRef]] pointing to the
 * same map.
 *
 * ### Implementing a custom `MapRef`
 *
 * You can also choose to implement your own `MapRef`s,
 * but you must make sure to report the parameters correctly
 * (otherwise, it can lead to **buffer overflow**) and make
 * sure the object holds a reference to whatever is keeping
 * the file descriptor from being closed. You may optionally
 * implement [[close]] if you completely own the FD.
 */
export interface MapRef extends MapInfo {
    /**
     * Readonly property holding the FD owned by this object.
     * Don't store this value elsewhere, query it
     * from here every time to make sure it's valid.
     *
     * Throws if `close()` was successfully called.
     */
    readonly fd: FD;
    /**
     * Closes the FD early. Instances don't necessarily support
     * this operation (and will throw in that case), but all
     * instances returned by this module do.
     *
     * If supported, calling it a second time does nothing.
     */
    close(): void;
}
/**
 * This interface implements a conversion between `Buffer`
 * and a user-defined representation. See [[u32type]] for
 * an example.
 */
export interface TypeConversion<X> {
    /** Parse a `Buffer` into user data */
    parse(buf: Buffer): X;
    /**
     * Write the user data into the passed `Buffer`
     * (which must *not* be assumed to be initialized)
     */
    format(buf: Buffer, x: X): void;
}
export declare class TypeConversionWrap<X> {
    readonly type: TypeConversion<X>;
    readonly size: number;
    constructor(type: TypeConversion<X>, size: number);
    parse(buf: Buffer): X;
    parseMaybe(buf: Buffer | undefined): X | undefined;
    format(x: X, out?: Buffer): Buffer;
    formatMaybe(x: X | undefined): Buffer | undefined;
}
/** [[TypeConversion]] for a single `uint32`, for convenience */
export declare const u32type: TypeConversion<number>;
/**
 * Create a new eBPF map. It is recommended to use [[close]]
 * if you're no longer going to need it at some point.
 *
 * @param desc Map parameters
 * @returns [[MapRef]] instance, holding a reference
 * to the newly created map, and its actual parameters
 */
export declare function createMap(desc: MapDef): MapRef;
/**
 * Given an existing file descriptor pointing to an eBPF map,
 * obtain its information and return a [[MapRef]] instance
 * pointing to that map (but creating a duplicate descriptor).
 *
 * **Note:** If `parameters` is passed, it will be used as
 * a fallback to build the `MapRef` for kernels older than 4.13.
 * Make sure it's correct. If not passed, the call will fail
 * for older kernels.
 *
 * If `transfer` is `true`, the passed FD itself is used
 * (taking ownership of it) instead of creating a new FD first.
 * Do this only if the FD isn't being used anywhere else.
 *
 * If the file descriptor is invalid, the function throws
 * without taking ownership. Note that there is no way to
 * check whether the FD actually points to an eBPF map,
 * the caller is responsible to check first.
 *
 * @param fd file descriptor
 * @param options options
 * @returns [[MapRef]] instance
 */
export declare function createMapRef(fd: number, options?: {
    parameters?: MapDef;
    transfer?: boolean;
}): MapRef;
/**
 * Get a [[MapRef]] to the eBPF map with specified ID.
 *
 * Since Linux 4.13.
 *
 * @param id Map ID
 * @returns [[MapRef]] instance
 */
export declare function openMap(id: number): MapRef;
export declare function fixCount(count: number | undefined, batchSize: number, status: number): number | undefined;
export declare function checkAllProcessed(count: number | undefined, batchSize: number): void;
/**
 * Get a file descriptor (fd) of a pinned eBPF object.
 *
 * Since Linux 4.4.
 *
 * @param path pinned eBPF object path
 * @returns fd file descriptor
 */
export declare function objGet(path: string): number;
