/// <reference types="node" />
import { MapRef, TypeConversion, MapDefOptional } from './common';
/**
 * Specialized version of [[IMap]] for `ARRAY` maps.
 *
 * [[RawArrayMap]] returns array values directly as `Buffer` with no
 * conversion, and [[ConvArrayMap]] performs the conversion specified
 * at construction time.
 *
 * Keep in mind that `ARRAY` maps aren't atomic at all.
 */
export interface IArrayMap<V> {
    /** Size of the array in items */
    readonly length: number;
    /**
     * Fetch the value at a certain index. Throws on invalid
     * indexes.
     *
     * @param key Array index
     * @param flags Operation flags (since Linux 5.1), see [[MapLookupFlags]]
     * @returns Array value
     * @category Operations
     */
    get(key: number, flags?: number): V;
    /**
     * Set the value at a certain index. Throws on invalid
     * indexes.
     *
     * @param key Array index
     * @param value Nwe value
     * @param flags Operation flags (since Linux 3.19), see [[MapUpdateFlags]]
     * @category Operations
     */
    set(key: number, value: V, flags?: number): this;
    /**
     * Iterate through the array values.
     *
     * This works like [[values]] but the iteration is performed
     * in the kernel, returning many items at once. The
     * interator yields each batch produced by the kernel, until
     * an error is found or there are no more entries.
     *
     * `batchSize` specifies the requested size, but batches may
     * be smaller. If the kernel returns a partial batch together
     * with an error, the partial batch will be yielded before
     * throwing the error. If the map is empty, nothing is yielded.
     *
     * Since Linux 5.6.
     *
     * @param batchSize Amount of entries to request per batch,
     * must be non-zero
     * @param flags Operation flags, see [[MapLookupFlags]]
     * @category Batched operations
     */
    getBatch(batchSize: number, flags?: number): IterableIterator<V[]>;
    /**
     * Sets a batch of array indexes to some values. Throws if
     * any of the indexes is invalid.
     *
     * Since Linux 5.6.
     *
     * Note that if an error is thrown, part of the entries
     * could already have been processed. The thrown error
     * includes a `count` field that, if not undefined,
     * corresponds to the amount of processed entries.
     *
     * @param entries Array entries to set (indexes are not
     * necessarily unique or sorted).
     * @param flags Operation flags, see [[MapUpdateFlags]]
     * @category Batched operations
     */
    setBatch(entries: [number, V][], flags?: number): this;
    /**
     * Freezes the map, making it non-modifiable from userspace.
     * The map stays writeable from BPF side.
     *
     * Since Linux 5.2.
     *
     * @category Operations
     */
    freeze(): void;
    /**
     * Fetches all values of the array using [[getBatch]].
     *
     * @category Convenience
     */
    getAll(): V[];
    /**
     * Sets all values of the array using [[setBatch]].
     *
     * Note that if an error is thrown, part of the entries
     * could already have been processed. The thrown error
     * includes a `count` field that, if not undefined,
     * corresponds to the amount of processed entries.
     *
     * @params values New array values (must contain exactly `length`
     * items)
     * @category Convenience
     */
    setAll(values: V[]): this;
    /**
     * Iterates through the values of the array.
     *
     * @category Convenience
     */
    values(): IterableIterator<V>;
    /**
     * Convenience function. Alias of [[values]].
     *
     * @category Convenience
     */
    [Symbol.iterator](): IterableIterator<V>;
}
/**
 * Raw version of the [[IArrayMap]] interface where values
 * are returned directly as `Buffer`s.
 */
export declare class RawArrayMap implements IArrayMap<Buffer> {
    readonly ref: MapRef;
    /** Buffer containing all indexes concatenated, to speed up [[getAll]] and [[setAll]] */
    private _allIndexes;
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `ARRAY` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     */
    constructor(ref: MapRef);
    private _checkBuf;
    private _getBuf;
    private _vBuf;
    private _vOrBuf;
    private _checkIndex;
    readonly length: number;
    get(key: number, flags?: number, out?: Buffer): Buffer;
    set(key: number, value: Buffer, flags?: number): this;
    getBatch(batchSize: number, flags?: number): IterableIterator<Buffer[]>;
    setBatch(entries: [number, Buffer][], flags?: number): this;
    freeze(): void;
    getAll(): Buffer[];
    setAll(values: Buffer[]): this;
    values(): IterableIterator<Buffer>;
    [Symbol.iterator](): IterableIterator<Buffer>;
}
/**
 * Implementation of [[IArrayMap]] that converts values
 * to 'parsed' representations using the given [[TypeConversion]].
 */
export declare class ConvArrayMap<V> implements IArrayMap<V> {
    private readonly map;
    private readonly valueConv;
    get ref(): MapRef;
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `ARRAY` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     * @param valueConv Type conversion for array values
     */
    constructor(ref: MapRef, valueConv: TypeConversion<V>);
    get length(): number;
    get(key: number, flags?: number): V;
    set(key: number, value: V, flags?: number): this;
    getBatch(batchSize: number, flags?: number): IterableIterator<V[]>;
    setBatch(entries: [number, V][], flags?: number): this;
    freeze(): void;
    getAll(): V[];
    setAll(values: V[]): this;
    values(): IterableIterator<V>;
    [Symbol.iterator](): IterableIterator<V>;
}
/**
 * Convenience function to create an `ARRAY` map using [[createMap]]
 * and construct a [[ConvArrayMap]] instance.
 *
 * @param length Array size, in items
 * @param valueSize Size of each value, in bytes (will be
 * rounded up to a multiple of 8)
 * @param valueConv Type conversion for values
 * @param options Other map options
 * @returns Map instance
 */
export declare function createArrayMap<V>(length: number, valueSize: number, valueConv: TypeConversion<V>, options?: MapDefOptional): ConvArrayMap<V>;
