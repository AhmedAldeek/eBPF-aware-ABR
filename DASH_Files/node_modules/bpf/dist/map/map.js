"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConvMap = exports.RawMap = void 0;
const os_1 = require("os");
const util_1 = require("../util");
const exception_1 = require("../exception");
const common_1 = require("./common");
const { ENOENT } = os_1.constants.errno;
/**
 * Raw version of the [[IMap]] interface where keys and values
 * are returned directly as `Buffer`s.
 */
class RawMap {
    /**
     * Construct a new instance operating on the given map.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     */
    constructor(ref) {
        this.ref = ref;
    }
    _checkBuf(size, x) {
        if (x.length !== size)
            throw Error(`Passed ${x.length} byte buffer, expected ${size}`);
        return x;
    }
    _getBuf(size, x) {
        if (x === undefined)
            return Buffer.alloc(size);
        return this._checkBuf(size, x);
    }
    _kBuf(x) {
        return this._checkBuf(this.ref.keySize, x);
    }
    _vBuf(x) {
        return this._checkBuf(this.ref.valueSize, x);
    }
    _kOrBuf(x) {
        return this._getBuf(this.ref.keySize, x);
    }
    _vOrBuf(x) {
        return this._getBuf(this.ref.valueSize, x);
    }
    // Base operations
    get(key, flags = 0, out) {
        this._kBuf(key);
        out = this._vOrBuf(out);
        const status = util_1.native.mapLookupElem(this.ref.fd, key, out, flags);
        if (status == -ENOENT)
            return undefined;
        exception_1.checkStatus('bpf_map_lookup_elem_flags', status);
        return out;
    }
    getDelete(key, out) {
        this._kBuf(key);
        out = this._vOrBuf(out);
        const status = util_1.native.mapLookupAndDeleteElem(this.ref.fd, key, out);
        if (status == -ENOENT)
            return undefined;
        exception_1.checkStatus('bpf_map_lookup_and_delete_elem', status);
        return out;
    }
    set(key, value, flags = 0) {
        this._kBuf(key);
        this._vBuf(value);
        const status = util_1.native.mapUpdateElem(this.ref.fd, key, value, flags);
        exception_1.checkStatus('bpf_map_update_elem', status);
        return this;
    }
    delete(key) {
        this._kBuf(key);
        const status = util_1.native.mapDeleteElem(this.ref.fd, key);
        if (status == -ENOENT)
            return false;
        exception_1.checkStatus('bpf_map_delete_elem', status);
        return true;
    }
    // Batched operations
    *getBatch(batchSize, flags = 0) {
        if (util_1.checkU32(batchSize) === 0)
            throw Error('Invalid batch size');
        const keysOut = Buffer.alloc(batchSize * this.ref.keySize);
        const valuesOut = Buffer.alloc(batchSize * this.ref.valueSize);
        const opts = { elemFlags: flags };
        let batchIn;
        let batchOut;
        while (true) {
            if (batchOut === undefined)
                batchOut = Buffer.alloc(this.ref.keySize);
            let [status, count] = util_1.native.mapLookupBatch(this.ref.fd, batchIn, batchOut, keysOut, valuesOut, batchSize, opts);
            [batchIn, batchOut] = [batchOut, batchIn];
            // there's an exception for ENOENT, apparently
            // https://github.com/torvalds/linux/blob/06a4ec1d9dc652e17ee3ac2ceb6c7cf6c2b75cdd/kernel/bpf/hashtab.c#L1530
            if (status !== -ENOENT)
                count = common_1.fixCount(count, batchSize, status);
            if (count > 0) {
                const entries = [];
                const copySlice = (i, buf, size) => {
                    const offset = i * size;
                    return Buffer.from(buf.slice(offset, offset + size));
                };
                for (let i = 0; i < count; i++)
                    entries.push([copySlice(i, keysOut, this.ref.keySize),
                        copySlice(i, valuesOut, this.ref.valueSize)]);
                yield entries;
            }
            if (status === -ENOENT)
                return;
            exception_1.checkStatus('bpf_map_lookup_batch', status);
        }
    }
    /* getDeleteBatch(keys: Buffer[], out?: Buffer): (Buffer | undefined)[] {
        throw Error('not implemented yet') // TODO
    } */
    setBatch(entries, flags = 0) {
        const keysBuf = Buffer.concat(entries.map(x => this._kBuf(x[0])));
        const valuesBuf = Buffer.concat(entries.map(x => this._vBuf(x[1])));
        let [status, count] = util_1.native.mapUpdateBatch(this.ref.fd, keysBuf, valuesBuf, entries.length, { elemFlags: flags });
        count = common_1.fixCount(count, entries.length, status);
        exception_1.checkStatus('bpf_map_update_batch', status, count);
        common_1.checkAllProcessed(count, entries.length);
        return this;
    }
    deleteBatch(keys) {
        keys.forEach(key => this._kBuf(key));
        const keysBuf = Buffer.concat(keys);
        let [status, count] = util_1.native.mapDeleteBatch(this.ref.fd, keysBuf, keys.length, {});
        count = common_1.fixCount(count, keys.length, status);
        exception_1.checkStatus('bpf_map_delete_batch', status, count);
        common_1.checkAllProcessed(count, keys.length);
    }
    // Other operations
    *keys(start) {
        let key = this.getNextKey(start);
        while (key !== undefined) {
            const next = this.getNextKey(key);
            yield key;
            key = next;
        }
        return undefined;
    }
    getNextKey(key, out) {
        // FIXME: if no key passed, implement fallback like BCC does
        key !== undefined && this._kBuf(key);
        out = this._kOrBuf(out);
        const status = util_1.native.mapGetNextKey(this.ref.fd, key, out);
        if (status == -ENOENT)
            return undefined;
        exception_1.checkStatus('bpf_map_get_next_key', status);
        return out;
    }
    freeze() {
        const status = util_1.native.mapFreeze(this.ref.fd);
        exception_1.checkStatus('bpf_map_freeze', status);
    }
    // Convenience functions
    has(key) {
        return this.get(key) !== undefined;
    }
    *entries(start) {
        for (const k of this.keys(start)) {
            const v = this.get(k);
            if (v) // entry could have been deleted by now
                yield [k, v];
        }
    }
    *values(start) {
        for (const [, v] of this.entries(start))
            yield v;
    }
    *consumeEntries(start) {
        for (const k of this.keys(start)) {
            const v = this.getDelete(k);
            if (v) // entry could have been deleted by now
                yield [k, v];
        }
    }
    clear(start) {
        for (const k of this.keys(start))
            this.delete(k);
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
exports.RawMap = RawMap;
/**
 * Implementation of [[IMap]] that converts keys and values
 * to 'parsed' representations using the given [[TypeConversion]].
 */
class ConvMap {
    /**
     * Construct a new instance operating on the given map.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     * @param keyConv Type conversion for keys
     * @param valueConv Type conversion for values
     */
    constructor(ref, keyConv, valueConv) {
        this.map = new RawMap(ref);
        this.keyConv = new common_1.TypeConversionWrap(keyConv, ref.keySize);
        this.valueConv = new common_1.TypeConversionWrap(valueConv, ref.valueSize);
    }
    get ref() {
        return this.map.ref;
    }
    get(key, flags) {
        return this.valueConv.parseMaybe(this.map.get(this.keyConv.format(key), flags));
    }
    getDelete(key) {
        return this.valueConv.parseMaybe(this.map.getDelete(this.keyConv.format(key)));
    }
    set(key, value, flags) {
        this.map.set(this.keyConv.format(key), this.valueConv.format(value), flags);
        return this;
    }
    delete(key) {
        return this.map.delete(this.keyConv.format(key));
    }
    *getBatch(batchSize, flags) {
        for (const entries of this.map.getBatch(batchSize, flags))
            yield entries.map(([k, v]) => [this.keyConv.parse(k), this.valueConv.parse(v)]);
    }
    /* getDeleteBatch(keys: K[]): (V | undefined)[] {
        return this.map.getDeleteBatch(keys.map(k => this.keyConv.format(k)))
            .map(v => this.valueConv.parseMaybe(v))
    } */
    setBatch(entries, flags) {
        this.map.setBatch(entries.map(([k, v]) => [this.keyConv.format(k), this.valueConv.format(v)]), flags);
        return this;
    }
    deleteBatch(keys) {
        return this.map.deleteBatch(keys.map(k => this.keyConv.format(k)));
    }
    *keys(start) {
        for (const k of this.map.keys(this.keyConv.formatMaybe(start)))
            yield this.keyConv.parse(k);
        return undefined;
    }
    freeze() {
        return this.map.freeze();
    }
    has(key) {
        return this.map.has(this.keyConv.format(key));
    }
    *entries(start) {
        for (const [k, v] of this.map.entries(this.keyConv.formatMaybe(start)))
            yield [this.keyConv.parse(k), this.valueConv.parse(v)];
    }
    *values(start) {
        for (const v of this.map.values(this.keyConv.formatMaybe(start)))
            yield this.valueConv.parse(v);
    }
    *consumeEntries(start) {
        for (const [k, v] of this.map.consumeEntries(this.keyConv.formatMaybe(start)))
            yield [this.keyConv.parse(k), this.valueConv.parse(v)];
    }
    clear(start) {
        return this.map.clear(this.keyConv.formatMaybe(start));
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
exports.ConvMap = ConvMap;
//# sourceMappingURL=map.js.map