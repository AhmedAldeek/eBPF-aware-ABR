/// <reference types="node" />
import { MapRef, TypeConversion, MapDefOptional } from './common';
/**
 * Specialized version of [[IMap]] for queue types, currently `QUEUE`
 * and `STACK`.
 *
 * [[RawQueueMap]] returns queue values directly as `Buffer` with no
 * conversion, and [[ConvQueueMap]] performs the conversion specified
 * at construction time.
 */
export interface IQueueMap<V> {
    /**
     * Get the next value without removing it from the queue.
     *
     * @param flags Operation flags (since Linux 5.1), see [[MapLookupFlags]]
     * @returns Entry value, or `undefined` if the queue is empty
     * @category Operations
     */
    peek(flags?: number): V | undefined;
    /**
     * Consume the next value from the queue.
     *
     * @returns Entry value, or `undefined` if the queue is empty
     * @category Operations
     */
    pop(): V | undefined;
    /**
     * Add a new value to the queue.
     *
     * @param value Entry value
     * @param flags Operation flags, see [[MapUpdateFlags]]
     * @category Operations
     */
    push(value: V, flags?: number): this;
    /**
     * Freezes the map, making it non-modifiable from userspace.
     * The map stays writeable from BPF side.
     *
     * Since Linux 5.2.
     *
     * @category Operations
     */
    freeze(): void;
    /**
     * Convenience function. Tests if the queue is empty.
     *
     * @category Convenience
     */
    empty(): boolean;
    /**
     * Convenience function. Consumes values repeatedly until
     * the queue is empty.
     *
     * In cases where another program is pushing things to the
     * queue concurrently, it is recommended to place a limit
     * to avoid loop starvation.
     *
     * @param limit Maximum amount of values to consume
     * @category Convenience
     */
    consumeValues(limit?: number): IterableIterator<V>;
    /**
     * Convenience function. Alias of [[consumeValues]].
     *
     * @category Convenience
     */
    [Symbol.iterator](): IterableIterator<V>;
}
/**
 * Raw version of the [[IQueueMap]] interface where values
 * are returned directly as `Buffer`s.
 */
export declare class RawQueueMap implements IQueueMap<Buffer> {
    readonly ref: MapRef;
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `QUEUE` or `STACK` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     */
    constructor(ref: MapRef);
    private _checkBuf;
    private _getBuf;
    private _vBuf;
    private _vOrBuf;
    peek(flags?: number, out?: Buffer): Buffer | undefined;
    pop(out?: Buffer): Buffer | undefined;
    push(value: Buffer, flags?: number): this;
    freeze(): void;
    empty(): boolean;
    consumeValues(limit?: number): IterableIterator<Buffer>;
    [Symbol.iterator](): IterableIterator<Buffer>;
}
/**
 * Implementation of [[IQueueMap]] that converts values
 * to 'parsed' representations using the given [[TypeConversion]].
 */
export declare class ConvQueueMap<V> implements IQueueMap<V> {
    private readonly map;
    private readonly valueConv;
    get ref(): MapRef;
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `QUEUE` or `STACK` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     * @param valueConv Type conversion for values
     */
    constructor(ref: MapRef, valueConv: TypeConversion<V>);
    peek(flags?: number): V | undefined;
    pop(): V | undefined;
    push(value: V, flags?: number): this;
    freeze(): void;
    empty(): boolean;
    consumeValues(limit?: number): IterableIterator<V>;
    [Symbol.iterator](): IterableIterator<V>;
}
/**
 * Convenience function to create a `QUEUE` map using [[createMap]]
 * and construct a [[ConvQueueMap]] instance.
 *
 * @param maxEntries Max entries
 * @param valueSize Size of each value, in bytes
 * @param valueConv Type conversion for values
 * @param options Other map options
 * @returns Map instance
 */
export declare function createQueueMap<V>(maxEntries: number, valueSize: number, valueConv: TypeConversion<V>, options?: MapDefOptional): ConvQueueMap<V>;
/**
 * Convenience function to create a `STACK` map using [[createMap]]
 * and construct a [[ConvQueueMap]] instance.
 *
 * @param maxEntries Max entries
 * @param valueSize Size of each value, in bytes
 * @param valueConv Type conversion for values
 * @param options Other map options
 * @returns Map instance
 */
export declare function createStackMap<V>(maxEntries: number, valueSize: number, valueConv: TypeConversion<V>, options?: MapDefOptional): ConvQueueMap<V>;
