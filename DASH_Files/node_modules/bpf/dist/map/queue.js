"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStackMap = exports.createQueueMap = exports.ConvQueueMap = exports.RawQueueMap = void 0;
const os_1 = require("os");
const util_1 = require("../util");
const exception_1 = require("../exception");
const common_1 = require("./common");
const constants_1 = require("../constants");
const { ENOENT } = os_1.constants.errno;
const empty = Buffer.alloc(0);
/**
 * Raw version of the [[IQueueMap]] interface where values
 * are returned directly as `Buffer`s.
 */
class RawQueueMap {
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `QUEUE` or `STACK` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     */
    constructor(ref) {
        if (ref.type !== constants_1.MapType.QUEUE && ref.type !== constants_1.MapType.STACK)
            throw new Error(`Expected queue or stack map, got type ${constants_1.MapType[ref.type] || ref.type}`);
        if (ref.keySize !== 0)
            throw new Error(`Assertion failed: keySize must be 0`);
        this.ref = ref;
    }
    _checkBuf(size, x) {
        if (x.length !== size)
            throw Error(`Passed ${x.length} byte buffer, expected ${size}`);
        return x;
    }
    _getBuf(size, x) {
        if (x === undefined)
            return Buffer.alloc(size);
        return this._checkBuf(size, x);
    }
    _vBuf(x) {
        return this._checkBuf(this.ref.valueSize, x);
    }
    _vOrBuf(x) {
        return this._getBuf(this.ref.valueSize, x);
    }
    // Base operations
    peek(flags = 0, out) {
        out = this._vOrBuf(out);
        const status = util_1.native.mapLookupElem(this.ref.fd, empty, out, flags);
        if (status == -ENOENT)
            return undefined;
        exception_1.checkStatus('bpf_map_lookup_elem_flags', status);
        return out;
    }
    pop(out) {
        out = this._vOrBuf(out);
        const status = util_1.native.mapLookupAndDeleteElem(this.ref.fd, empty, out);
        if (status == -ENOENT)
            return undefined;
        exception_1.checkStatus('bpf_map_lookup_and_delete_elem', status);
        return out;
    }
    push(value, flags = 0) {
        this._vBuf(value);
        const status = util_1.native.mapUpdateElem(this.ref.fd, empty, value, flags);
        exception_1.checkStatus('bpf_map_update_elem', status);
        return this;
    }
    // Other operations
    freeze() {
        const status = util_1.native.mapFreeze(this.ref.fd);
        exception_1.checkStatus('bpf_map_freeze', status);
    }
    // Convenience functions
    empty() {
        return this.peek() === undefined;
    }
    *consumeValues(limit) {
        let value;
        if (limit === undefined) {
            while ((value = this.pop()) !== undefined)
                yield value;
        }
        else {
            for (let i = 0; i < limit && (value = this.pop()) !== undefined; i++)
                yield value;
        }
    }
    [Symbol.iterator]() {
        return this.consumeValues();
    }
}
exports.RawQueueMap = RawQueueMap;
/**
 * Implementation of [[IQueueMap]] that converts values
 * to 'parsed' representations using the given [[TypeConversion]].
 */
class ConvQueueMap {
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `QUEUE` or `STACK` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     * @param valueConv Type conversion for values
     */
    constructor(ref, valueConv) {
        this.map = new RawQueueMap(ref);
        this.valueConv = new common_1.TypeConversionWrap(valueConv, ref.valueSize);
    }
    get ref() {
        return this.map.ref;
    }
    peek(flags) {
        return this.valueConv.parseMaybe(this.map.peek(flags));
    }
    pop() {
        return this.valueConv.parseMaybe(this.map.pop());
    }
    push(value, flags) {
        this.map.push(this.valueConv.format(value), flags);
        return this;
    }
    freeze() {
        return this.map.freeze();
    }
    empty() {
        return this.map.empty();
    }
    *consumeValues(limit) {
        for (const v of this.map.consumeValues(limit))
            yield this.valueConv.parse(v);
    }
    [Symbol.iterator]() {
        return this.consumeValues();
    }
}
exports.ConvQueueMap = ConvQueueMap;
/**
 * Convenience function to create a `QUEUE` map using [[createMap]]
 * and construct a [[ConvQueueMap]] instance.
 *
 * @param maxEntries Max entries
 * @param valueSize Size of each value, in bytes
 * @param valueConv Type conversion for values
 * @param options Other map options
 * @returns Map instance
 */
function createQueueMap(maxEntries, valueSize, valueConv, options) {
    const ref = common_1.createMap({
        ...options,
        type: constants_1.MapType.QUEUE,
        keySize: 0,
        maxEntries,
        valueSize,
    });
    return new ConvQueueMap(ref, valueConv);
}
exports.createQueueMap = createQueueMap;
/**
 * Convenience function to create a `STACK` map using [[createMap]]
 * and construct a [[ConvQueueMap]] instance.
 *
 * @param maxEntries Max entries
 * @param valueSize Size of each value, in bytes
 * @param valueConv Type conversion for values
 * @param options Other map options
 * @returns Map instance
 */
function createStackMap(maxEntries, valueSize, valueConv, options) {
    const ref = common_1.createMap({
        ...options,
        type: constants_1.MapType.STACK,
        keySize: 0,
        maxEntries,
        valueSize,
    });
    return new ConvQueueMap(ref, valueConv);
}
exports.createStackMap = createStackMap;
//# sourceMappingURL=queue.js.map