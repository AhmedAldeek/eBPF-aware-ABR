"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createArrayMap = exports.ConvArrayMap = exports.RawArrayMap = void 0;
const os_1 = require("os");
const util_1 = require("../util");
const exception_1 = require("../exception");
const common_1 = require("./common");
const constants_1 = require("../constants");
const { ENOENT } = os_1.constants.errno;
/**
 * Raw version of the [[IArrayMap]] interface where values
 * are returned directly as `Buffer`s.
 */
class RawArrayMap {
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `ARRAY` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     */
    constructor(ref) {
        if (ref.type !== constants_1.MapType.ARRAY)
            throw new Error(`Expected array map, got type ${constants_1.MapType[ref.type] || ref.type}`);
        this.ref = ref;
        this.length = util_1.checkU32(ref.maxEntries);
        this._allIndexes = util_1.asUint8Array(new Uint32Array(this.length).map((_, i) => i));
    }
    _checkBuf(size, x) {
        if (x.length !== size)
            throw Error(`Passed ${x.length} byte buffer, expected ${size}`);
        return x;
    }
    _getBuf(size, x) {
        if (x === undefined)
            return Buffer.alloc(size);
        return this._checkBuf(size, x);
    }
    _vBuf(x) {
        return this._checkBuf(this.ref.valueSize, x);
    }
    _vOrBuf(x) {
        return this._getBuf(this.ref.valueSize, x);
    }
    _checkIndex(x) {
        util_1.checkU32(x);
        if (x >= this.length)
            throw new RangeError(`Invalid index ${x} for array of length ${this.length}`);
        return x;
    }
    // Base operations
    get(key, flags = 0, out) {
        const keyBuf = util_1.asUint8Array(Uint32Array.of(this._checkIndex(key)));
        out = this._vOrBuf(out);
        const status = util_1.native.mapLookupElem(this.ref.fd, keyBuf, out, flags);
        exception_1.checkStatus('bpf_map_lookup_elem_flags', status);
        return out;
    }
    set(key, value, flags = 0) {
        const keyBuf = util_1.asUint8Array(Uint32Array.of(this._checkIndex(key)));
        this._vBuf(value);
        const status = util_1.native.mapUpdateElem(this.ref.fd, keyBuf, value, flags);
        exception_1.checkStatus('bpf_map_update_elem', status);
        return this;
    }
    // FIXME: maybe try to mirror TypedArrays a bit more? i.e. set method
    // Batched operations
    *getBatch(batchSize, flags = 0) {
        if (util_1.checkU32(batchSize) === 0)
            throw Error('Invalid batch size');
        let idx = 0;
        const keysIdx = new Uint32Array(batchSize);
        const keysOut = util_1.asUint8Array(keysIdx);
        const valuesOut = Buffer.alloc(batchSize * this.ref.valueSize);
        const opts = { elemFlags: flags };
        let batchIn;
        let batchOut;
        while (true) {
            if (batchOut === undefined)
                batchOut = Buffer.alloc(this.ref.keySize);
            let [status, count] = util_1.native.mapLookupBatch(this.ref.fd, batchIn, batchOut, keysOut, valuesOut, batchSize, opts);
            [batchIn, batchOut] = [batchOut, batchIn];
            // there's an exception for ENOENT, apparently
            // https://github.com/torvalds/linux/blob/06a4ec1d9dc652e17ee3ac2ceb6c7cf6c2b75cdd/kernel/bpf/hashtab.c#L1530
            if (status !== -ENOENT)
                count = common_1.fixCount(count, batchSize, status);
            if (count > 0) {
                const entries = [];
                const copySlice = (i, buf, size) => {
                    const offset = i * size;
                    return Buffer.from(buf.slice(offset, offset + size));
                };
                for (let i = 0; i < count; i++) {
                    if (keysIdx[i] !== (idx++))
                        throw Error('Non-sequential indexes');
                    entries.push(copySlice(i, valuesOut, this.ref.valueSize));
                }
                yield entries;
            }
            if (status === -ENOENT)
                return;
            exception_1.checkStatus('bpf_map_lookup_batch', status);
        }
    }
    setBatch(entries, flags = 0) {
        const keysBuf = util_1.asUint8Array(Uint32Array.from(entries, x => this._checkIndex(x[0])));
        const valuesBuf = Buffer.concat(entries.map(x => x[1]));
        let [status, count] = util_1.native.mapUpdateBatch(this.ref.fd, keysBuf, valuesBuf, entries.length, { elemFlags: flags });
        count = common_1.fixCount(count, entries.length, status);
        exception_1.checkStatus('bpf_map_update_batch', status, count);
        common_1.checkAllProcessed(count, entries.length);
        return this;
    }
    // Other operations
    freeze() {
        const status = util_1.native.mapFreeze(this.ref.fd);
        exception_1.checkStatus('bpf_map_freeze', status);
    }
    // Convenience functions
    getAll() {
        const keysOut = Buffer.alloc(this.length * this.ref.keySize);
        const valuesOut = Buffer.alloc(this.length * this.ref.valueSize);
        const batchOut = Buffer.alloc(this.ref.keySize);
        let [status, count] = util_1.native.mapLookupBatch(this.ref.fd, undefined, batchOut, keysOut, valuesOut, this.length, {});
        if (status !== -ENOENT)
            exception_1.checkStatus('bpf_map_lookup_batch', status);
        if (count !== this.length)
            throw Error(`Expected ${this.length} elements but received ${count}`);
        if (!keysOut.equals(this._allIndexes))
            throw Error('Non-sequential indexes');
        return util_1.sliceBuffer(valuesOut, count, this.ref.valueSize);
    }
    setAll(values) {
        if (values.length !== this.length)
            throw new Error(`Expected ${this.length} values, got ${values.length}`);
        const valuesBuf = Buffer.concat(values.map(x => this._vBuf(x)));
        let [status, count] = util_1.native.mapUpdateBatch(this.ref.fd, this._allIndexes, valuesBuf, this.length, {});
        count = common_1.fixCount(count, this.length, status);
        exception_1.checkStatus('bpf_map_update_batch', status, count);
        common_1.checkAllProcessed(count, this.length);
        return this;
    }
    *values() {
        for (let i = 0; i < this.length; i++)
            yield this.get(i);
    }
    [Symbol.iterator]() {
        return this.values();
    }
}
exports.RawArrayMap = RawArrayMap;
/**
 * Implementation of [[IArrayMap]] that converts values
 * to 'parsed' representations using the given [[TypeConversion]].
 */
class ConvArrayMap {
    /**
     * Construct a new instance operating on the given map.
     *
     * The map must be of `ARRAY` type.
     *
     * @param ref Reference to the map. See [[MapRef]] if
     * you want to implement your own instances.
     * @param valueConv Type conversion for array values
     */
    constructor(ref, valueConv) {
        this.map = new RawArrayMap(ref);
        this.valueConv = new common_1.TypeConversionWrap(valueConv, ref.valueSize);
    }
    get ref() {
        return this.map.ref;
    }
    get length() {
        return this.map.length;
    }
    get(key, flags) {
        return this.valueConv.parse(this.map.get(key, flags));
    }
    set(key, value, flags) {
        this.map.set(key, this.valueConv.format(value), flags);
        return this;
    }
    *getBatch(batchSize, flags) {
        for (const values of this.map.getBatch(batchSize, flags))
            yield values.map(v => this.valueConv.parse(v));
    }
    setBatch(entries, flags) {
        this.map.setBatch(entries.map(([k, v]) => [k, this.valueConv.format(v)]), flags);
        return this;
    }
    freeze() {
        return this.map.freeze();
    }
    getAll() {
        return this.map.getAll().map(v => this.valueConv.parse(v));
    }
    setAll(values) {
        this.map.setAll(values.map(v => this.valueConv.format(v)));
        return this;
    }
    *values() {
        for (const v of this.map.values())
            yield this.valueConv.parse(v);
    }
    [Symbol.iterator]() {
        return this.values();
    }
}
exports.ConvArrayMap = ConvArrayMap;
/**
 * Convenience function to create an `ARRAY` map using [[createMap]]
 * and construct a [[ConvArrayMap]] instance.
 *
 * @param length Array size, in items
 * @param valueSize Size of each value, in bytes (will be
 * rounded up to a multiple of 8)
 * @param valueConv Type conversion for values
 * @param options Other map options
 * @returns Map instance
 */
function createArrayMap(length, valueSize, valueConv, options) {
    const ref = common_1.createMap({
        ...options,
        type: constants_1.MapType.ARRAY,
        keySize: 4,
        maxEntries: length,
        valueSize,
    });
    return new ConvArrayMap(ref, valueConv);
}
exports.createArrayMap = createArrayMap;
//# sourceMappingURL=array.js.map