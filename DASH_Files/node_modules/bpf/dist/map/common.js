"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objGet = exports.checkAllProcessed = exports.fixCount = exports.openMap = exports.createMapRef = exports.createMap = exports.u32type = exports.TypeConversionWrap = void 0;
const os_1 = require("os");
const util_1 = require("../util");
const exception_1 = require("../exception");
const constants_1 = require("../constants");
const { EFAULT, EINVAL } = os_1.constants.errno;
class TypeConversionWrap {
    constructor(type, size) {
        this.type = type;
        this.size = size;
    }
    parse(buf) {
        return this.type.parse(buf);
    }
    parseMaybe(buf) {
        return buf === undefined ? undefined : this.parse(buf);
    }
    format(x, out = Buffer.alloc(this.size)) {
        this.type.format(out, x);
        return out;
    }
    formatMaybe(x) {
        return x === undefined ? undefined : this.format(x);
    }
}
exports.TypeConversionWrap = TypeConversionWrap;
/** [[TypeConversion]] for a single `uint32`, for convenience */
exports.u32type = {
    parse: (buf) => util_1.asUint32Array(buf, 1)[0],
    format: (buf, x) => util_1.asUint32Array(buf, 1)[0] = x,
};
/**
 * Create a new eBPF map. It is recommended to use [[close]]
 * if you're no longer going to need it at some point.
 *
 * @param desc Map parameters
 * @returns [[MapRef]] instance, holding a reference
 * to the newly created map, and its actual parameters
 */
function createMap(desc) {
    let innerRef;
    try {
        // prevent people from accidentally passing -1 or similar
        util_1.checkU32(desc.keySize);
        util_1.checkU32(desc.valueSize);
        util_1.checkU32(desc.maxEntries);
        desc = { flags: 0, ...desc };
        if (desc.numaNode !== undefined)
            desc.flags |= constants_1.MapFlags.NUMA_NODE;
        if (desc.innerMap !== undefined && typeof desc.innerMap !== 'number') {
            let fd;
            try {
                ;
                ({ fd } = desc.innerMap);
            }
            catch (e) { }
            if (fd === undefined) {
                innerRef = createMap(desc.innerMap);
                fd = innerRef.fd;
            }
            desc.innerMap = fd;
        }
        const status = util_1.native.createMap(desc);
        exception_1.checkStatus('bpf_create_map_xattr', status);
        return createMapRef(status, { transfer: true, parameters: desc });
    }
    finally {
        innerRef && innerRef.close();
    }
}
exports.createMap = createMap;
/**
 * Given an existing file descriptor pointing to an eBPF map,
 * obtain its information and return a [[MapRef]] instance
 * pointing to that map (but creating a duplicate descriptor).
 *
 * **Note:** If `parameters` is passed, it will be used as
 * a fallback to build the `MapRef` for kernels older than 4.13.
 * Make sure it's correct. If not passed, the call will fail
 * for older kernels.
 *
 * If `transfer` is `true`, the passed FD itself is used
 * (taking ownership of it) instead of creating a new FD first.
 * Do this only if the FD isn't being used anywhere else.
 *
 * If the file descriptor is invalid, the function throws
 * without taking ownership. Note that there is no way to
 * check whether the FD actually points to an eBPF map,
 * the caller is responsible to check first.
 *
 * @param fd file descriptor
 * @param options options
 * @returns [[MapRef]] instance
 */
function createMapRef(fd, options) {
    if (!(options && options.transfer)) {
        fd = util_1.native.dup(fd);
        exception_1.checkStatus('dup', fd);
    }
    const ref = new util_1.native.FDRef(fd);
    const [status, info] = util_1.native.getMapInfo(fd);
    if (status === -EINVAL && (options === null || options === void 0 ? void 0 : options.parameters)) {
        // Fall back to building MapRef manually using MapDef as info
        const desc = options === null || options === void 0 ? void 0 : options.parameters;
        ref.type = desc.type;
        ref.keySize = desc.keySize;
        ref.valueSize = desc.valueSize;
        ref.maxEntries = desc.maxEntries;
        ref.flags = desc.flags || 0;
    }
    else {
        exception_1.checkStatus('bpf_obj_get_info_by_fd', status);
        Object.assign(ref, info);
    }
    Object.freeze(ref); // prevent changes to the info
    return ref;
}
exports.createMapRef = createMapRef;
/**
 * Get a [[MapRef]] to the eBPF map with specified ID.
 *
 * Since Linux 4.13.
 *
 * @param id Map ID
 * @returns [[MapRef]] instance
 */
function openMap(id) {
    const status = util_1.native.mapGetFdById(id);
    exception_1.checkStatus('bpf_map_get_fd_by_id', status);
    return createMapRef(status, { transfer: true });
}
exports.openMap = openMap;
// Utils for map interfaces
function fixCount(count, batchSize, status) {
    if (status < 0 && count === batchSize) {
        // it's impossible to have an error if all entries were processed,
        // that must mean count wasn't updated
        count = (status === -EFAULT) ? undefined : 0;
    }
    return count;
}
exports.fixCount = fixCount;
function checkAllProcessed(count, batchSize) {
    if (count !== batchSize) {
        // it's impossible to have no error if some entries weren't processed
        throw Error(`Assertion failed: ${count} of ${batchSize} entries processed`);
    }
}
exports.checkAllProcessed = checkAllProcessed;
/**
 * Get a file descriptor (fd) of a pinned eBPF object.
 *
 * Since Linux 4.4.
 *
 * @param path pinned eBPF object path
 * @returns fd file descriptor
 */
function objGet(path) {
    const fd = util_1.native.bpfObjGet(path);
    exception_1.checkStatus('bpf_obj_get', fd);
    return fd;
}
exports.objGet = objGet;
//# sourceMappingURL=common.js.map