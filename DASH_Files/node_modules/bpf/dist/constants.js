"use strict";
/**
 * Exports BPF uapi enums and other constants.
 *
 * Keep synchronized with `deps/libbpf/include/uapi/linux/bpf.h`.
 * For practicity, we omit the UNSPEC = 0 key from each enum, if present.
 */
/** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapLookupFlags = exports.MapUpdateFlags = exports.MapFlags = exports.MapType = exports.AttachType = exports.ProgramType = exports.OBJ_NAME_LEN = void 0;
/**
 * Maximum length of object names, in bytes, including NUL terminator.
 * Longer names will be truncated.
 */
exports.OBJ_NAME_LEN = 16;
var ProgramType;
(function (ProgramType) {
    ProgramType[ProgramType["SOCKET_FILTER"] = 1] = "SOCKET_FILTER";
    ProgramType[ProgramType["KPROBE"] = 2] = "KPROBE";
    ProgramType[ProgramType["SCHED_CLS"] = 3] = "SCHED_CLS";
    ProgramType[ProgramType["SCHED_ACT"] = 4] = "SCHED_ACT";
    ProgramType[ProgramType["TRACEPOINT"] = 5] = "TRACEPOINT";
    ProgramType[ProgramType["XDP"] = 6] = "XDP";
    ProgramType[ProgramType["PERF_EVENT"] = 7] = "PERF_EVENT";
    ProgramType[ProgramType["CGROUP_SKB"] = 8] = "CGROUP_SKB";
    ProgramType[ProgramType["CGROUP_SOCK"] = 9] = "CGROUP_SOCK";
    ProgramType[ProgramType["LWT_IN"] = 10] = "LWT_IN";
    ProgramType[ProgramType["LWT_OUT"] = 11] = "LWT_OUT";
    ProgramType[ProgramType["LWT_XMIT"] = 12] = "LWT_XMIT";
    ProgramType[ProgramType["SOCK_OPS"] = 13] = "SOCK_OPS";
    ProgramType[ProgramType["SK_SKB"] = 14] = "SK_SKB";
    ProgramType[ProgramType["CGROUP_DEVICE"] = 15] = "CGROUP_DEVICE";
    ProgramType[ProgramType["SK_MSG"] = 16] = "SK_MSG";
    ProgramType[ProgramType["RAW_TRACEPOINT"] = 17] = "RAW_TRACEPOINT";
    ProgramType[ProgramType["CGROUP_SOCK_ADDR"] = 18] = "CGROUP_SOCK_ADDR";
    ProgramType[ProgramType["LWT_SEG6LOCAL"] = 19] = "LWT_SEG6LOCAL";
    ProgramType[ProgramType["LIRC_MODE2"] = 20] = "LIRC_MODE2";
    ProgramType[ProgramType["SK_REUSEPORT"] = 21] = "SK_REUSEPORT";
    ProgramType[ProgramType["FLOW_DISSECTOR"] = 22] = "FLOW_DISSECTOR";
    ProgramType[ProgramType["CGROUP_SYSCTL"] = 23] = "CGROUP_SYSCTL";
    ProgramType[ProgramType["RAW_TRACEPOINT_WRITABLE"] = 24] = "RAW_TRACEPOINT_WRITABLE";
    ProgramType[ProgramType["CGROUP_SOCKOPT"] = 25] = "CGROUP_SOCKOPT";
    ProgramType[ProgramType["TRACING"] = 26] = "TRACING";
    ProgramType[ProgramType["STRUCT_OPS"] = 27] = "STRUCT_OPS";
    ProgramType[ProgramType["EXT"] = 28] = "EXT";
    ProgramType[ProgramType["LSM"] = 29] = "LSM";
    ProgramType[ProgramType["SK_LOOKUP"] = 30] = "SK_LOOKUP";
})(ProgramType = exports.ProgramType || (exports.ProgramType = {}));
var AttachType;
(function (AttachType) {
    AttachType[AttachType["CGROUP_INET_INGRESS"] = 0] = "CGROUP_INET_INGRESS";
    AttachType[AttachType["CGROUP_INET_EGRESS"] = 1] = "CGROUP_INET_EGRESS";
    AttachType[AttachType["CGROUP_INET_SOCK_CREATE"] = 2] = "CGROUP_INET_SOCK_CREATE";
    AttachType[AttachType["CGROUP_SOCK_OPS"] = 3] = "CGROUP_SOCK_OPS";
    AttachType[AttachType["SK_SKB_STREAM_PARSER"] = 4] = "SK_SKB_STREAM_PARSER";
    AttachType[AttachType["SK_SKB_STREAM_VERDICT"] = 5] = "SK_SKB_STREAM_VERDICT";
    AttachType[AttachType["CGROUP_DEVICE"] = 6] = "CGROUP_DEVICE";
    AttachType[AttachType["SK_MSG_VERDICT"] = 7] = "SK_MSG_VERDICT";
    AttachType[AttachType["CGROUP_INET4_BIND"] = 8] = "CGROUP_INET4_BIND";
    AttachType[AttachType["CGROUP_INET6_BIND"] = 9] = "CGROUP_INET6_BIND";
    AttachType[AttachType["CGROUP_INET4_CONNECT"] = 10] = "CGROUP_INET4_CONNECT";
    AttachType[AttachType["CGROUP_INET6_CONNECT"] = 11] = "CGROUP_INET6_CONNECT";
    AttachType[AttachType["CGROUP_INET4_POST_BIND"] = 12] = "CGROUP_INET4_POST_BIND";
    AttachType[AttachType["CGROUP_INET6_POST_BIND"] = 13] = "CGROUP_INET6_POST_BIND";
    AttachType[AttachType["CGROUP_UDP4_SENDMSG"] = 14] = "CGROUP_UDP4_SENDMSG";
    AttachType[AttachType["CGROUP_UDP6_SENDMSG"] = 15] = "CGROUP_UDP6_SENDMSG";
    AttachType[AttachType["LIRC_MODE2"] = 16] = "LIRC_MODE2";
    AttachType[AttachType["FLOW_DISSECTOR"] = 17] = "FLOW_DISSECTOR";
    AttachType[AttachType["CGROUP_SYSCTL"] = 18] = "CGROUP_SYSCTL";
    AttachType[AttachType["CGROUP_UDP4_RECVMSG"] = 19] = "CGROUP_UDP4_RECVMSG";
    AttachType[AttachType["CGROUP_UDP6_RECVMSG"] = 20] = "CGROUP_UDP6_RECVMSG";
    AttachType[AttachType["CGROUP_GETSOCKOPT"] = 21] = "CGROUP_GETSOCKOPT";
    AttachType[AttachType["CGROUP_SETSOCKOPT"] = 22] = "CGROUP_SETSOCKOPT";
    AttachType[AttachType["TRACE_RAW_TP"] = 23] = "TRACE_RAW_TP";
    AttachType[AttachType["TRACE_FENTRY"] = 24] = "TRACE_FENTRY";
    AttachType[AttachType["TRACE_FEXIT"] = 25] = "TRACE_FEXIT";
    AttachType[AttachType["MODIFY_RETURN"] = 26] = "MODIFY_RETURN";
    AttachType[AttachType["LSM_MAC"] = 27] = "LSM_MAC";
    AttachType[AttachType["TRACE_ITER"] = 28] = "TRACE_ITER";
    AttachType[AttachType["CGROUP_INET4_GETPEERNAME"] = 29] = "CGROUP_INET4_GETPEERNAME";
    AttachType[AttachType["CGROUP_INET6_GETPEERNAME"] = 30] = "CGROUP_INET6_GETPEERNAME";
    AttachType[AttachType["CGROUP_INET4_GETSOCKNAME"] = 31] = "CGROUP_INET4_GETSOCKNAME";
    AttachType[AttachType["CGROUP_INET6_GETSOCKNAME"] = 32] = "CGROUP_INET6_GETSOCKNAME";
    AttachType[AttachType["XDP_DEVMAP"] = 33] = "XDP_DEVMAP";
    AttachType[AttachType["CGROUP_INET_SOCK_RELEASE"] = 34] = "CGROUP_INET_SOCK_RELEASE";
    AttachType[AttachType["XDP_CPUMAP"] = 35] = "XDP_CPUMAP";
    AttachType[AttachType["SK_LOOKUP"] = 36] = "SK_LOOKUP";
    AttachType[AttachType["XDP"] = 37] = "XDP";
    AttachType[AttachType["SK_SKB_VERDICT"] = 38] = "SK_SKB_VERDICT";
})(AttachType = exports.AttachType || (exports.AttachType = {}));
var MapType;
(function (MapType) {
    /** [Hash](https://github.com/torvalds/linux/commit/0f8e4bd8a1fc8c4185f1630061d0a1f2d197a475) (since Linux 3.19) */
    MapType[MapType["HASH"] = 1] = "HASH";
    /** [Array](https://github.com/torvalds/linux/commit/28fbcfa08d8ed7c5a50d41a0433aad222835e8e3) (since Linux 3.19) */
    MapType[MapType["ARRAY"] = 2] = "ARRAY";
    /** [Tail call](https://github.com/torvalds/linux/commit/04fd61ab36ec065e194ab5e74ae34a5240d992bb) (since Linux 4.2) */
    MapType[MapType["PROG_ARRAY"] = 3] = "PROG_ARRAY";
    /** [Perf events](https://github.com/torvalds/linux/commit/ea317b267e9d03a8241893aa176fba7661d07579) (since Linux 4.3) */
    MapType[MapType["PERF_EVENT_ARRAY"] = 4] = "PERF_EVENT_ARRAY";
    /** [Per-CPU hash](https://github.com/torvalds/linux/commit/824bd0ce6c7c43a9e1e210abf124958e54d88342) (since Linux 4.6) */
    MapType[MapType["PERCPU_HASH"] = 5] = "PERCPU_HASH";
    /** [Per-CPU array](https://github.com/torvalds/linux/commit/a10423b87a7eae75da79ce80a8d9475047a674ee) (since Linux 4.6) */
    MapType[MapType["PERCPU_ARRAY"] = 6] = "PERCPU_ARRAY";
    /** [Stack trace](https://github.com/torvalds/linux/commit/d5a3b1f691865be576c2bffa708549b8cdccda19) (since Linux 4.6) */
    MapType[MapType["STACK_TRACE"] = 7] = "STACK_TRACE";
    /** [cgroup array](https://github.com/torvalds/linux/commit/4ed8ec521ed57c4e207ad464ca0388776de74d4b) (since Linux 4.8) */
    MapType[MapType["CGROUP_ARRAY"] = 8] = "CGROUP_ARRAY";
    /** [LRU hash](https://github.com/torvalds/linux/commit/3a08c2fd763450a927d1130de078d6f9e74944fb) (since Linux 4.10) */
    MapType[MapType["LRU_HASH"] = 9] = "LRU_HASH";
    /** [LRU per-CPU hash](https://github.com/torvalds/linux/commit/961578b63474d13ad0e2f615fcc2901c5197dda6) (since Linux 4.10) */
    MapType[MapType["LRU_PERCPU_HASH"] = 10] = "LRU_PERCPU_HASH";
    /** [LPM trie (longest-prefix match)](https://github.com/torvalds/linux/commit/b95a5c4db09bc7c253636cb84dc9b12c577fd5a0) (since Linux 4.11) */
    MapType[MapType["LPM_TRIE"] = 11] = "LPM_TRIE";
    /** [Array of maps](https://github.com/torvalds/linux/commit/56f668dfe00dcf086734f1c42ea999398fad6572) (since Linux 4.12) */
    MapType[MapType["ARRAY_OF_MAPS"] = 12] = "ARRAY_OF_MAPS";
    /** [Hash of maps](https://github.com/torvalds/linux/commit/bcc6b1b7ebf857a9fe56202e2be3361131588c15) (since Linux 4.12) */
    MapType[MapType["HASH_OF_MAPS"] = 13] = "HASH_OF_MAPS";
    /** [Netdevice references](https://github.com/torvalds/linux/commit/546ac1ffb70d25b56c1126940e5ec639c4dd7413) (since Linux 4.14) */
    MapType[MapType["DEVMAP"] = 14] = "DEVMAP";
    /** [Socket references (array)](https://github.com/torvalds/linux/commit/174a79ff9515f400b9a6115643dafd62a635b7e6) (since Linux 4.14) */
    MapType[MapType["SOCKMAP"] = 15] = "SOCKMAP";
    /** [CPU references](https://github.com/torvalds/linux/commit/6710e1126934d8b4372b4d2f9ae1646cd3f151bf) (since Linux 4.15) */
    MapType[MapType["CPUMAP"] = 16] = "CPUMAP";
    /** [AF_XDP socket (XSK) references](https://github.com/torvalds/linux/commit/fbfc504a24f53f7ebe128ab55cb5dba634f4ece8) (since Linux 4.18) */
    MapType[MapType["XSKMAP"] = 17] = "XSKMAP";
    /** [Socket references (hashmap)](https://github.com/torvalds/linux/commit/81110384441a59cff47430f20f049e69b98c17f4) (since Linux 4.18) */
    MapType[MapType["SOCKHASH"] = 18] = "SOCKHASH";
    /** [cgroup storage](https://github.com/torvalds/linux/commit/de9cbbaadba5adf88a19e46df61f7054000838f6) (since Linux 4.19) */
    MapType[MapType["CGROUP_STORAGE"] = 19] = "CGROUP_STORAGE";
    /** [reuseport sockarray](https://github.com/torvalds/linux/commit/5dc4c4b7d4e8115e7cde96a030f98cb3ab2e458c) (since Linux 4.19) */
    MapType[MapType["REUSEPORT_SOCKARRAY"] = 20] = "REUSEPORT_SOCKARRAY";
    /** [precpu cgroup storage](https://github.com/torvalds/linux/commit/b741f1630346defcbc8cc60f1a2bdae8b3b0036f) (since Linux 4.20) */
    MapType[MapType["PERCPU_CGROUP_STORAGE"] = 21] = "PERCPU_CGROUP_STORAGE";
    /** [queue](https://github.com/torvalds/linux/commit/f1a2e44a3aeccb3ff18d3ccc0b0203e70b95bd92) (since Linux 4.20) */
    MapType[MapType["QUEUE"] = 22] = "QUEUE";
    /** [stack](https://github.com/torvalds/linux/commit/f1a2e44a3aeccb3ff18d3ccc0b0203e70b95bd92) (since Linux 4.20) */
    MapType[MapType["STACK"] = 23] = "STACK";
    /** [socket local storage](https://github.com/torvalds/linux/commit/6ac99e8f23d4b10258406ca0dd7bffca5f31da9d) (since Linux 5.2) */
    MapType[MapType["SK_STORAGE"] = 24] = "SK_STORAGE";
    /** [Netdevice references (hashmap)](https://github.com/torvalds/linux/commit/6f9d451ab1a33728adb72d7ff66a7b374d665176) (since Linux 5.4) */
    MapType[MapType["DEVMAP_HASH"] = 25] = "DEVMAP_HASH";
    /** [struct ops](https://github.com/torvalds/linux/commit/85d33df357b634649ddbe0a20fd2d0fc5732c3cb) (since Linux 5.6) */
    MapType[MapType["STRUCT_OPS"] = 26] = "STRUCT_OPS";
    /** [ring buffer](https://github.com/torvalds/linux/commit/457f44363a8894135c85b7a9afd2bd8196db24ab) (since Linux 5.8) */
    MapType[MapType["RINGBUF"] = 27] = "RINGBUF";
})(MapType = exports.MapType || (exports.MapType = {}));
var MapFlags;
(function (MapFlags) {
    /**
     * Don't preallocate map memory (since Linux 4.6;
     * memory wasn't preallocated before)
     */
    MapFlags[MapFlags["NO_PREALLOC"] = 1] = "NO_PREALLOC";
    /**
     * Instead of having one common LRU list in the
     * BPF_MAP_TYPE_LRU_[PERCPU_]HASH map, use a percpu LRU list
     * which can scale and perform better.
     * Note, the LRU nodes (including free nodes) cannot be moved
     * across different LRU lists.
     */
    MapFlags[MapFlags["NO_COMMON_LRU"] = 2] = "NO_COMMON_LRU";
    /** Specify NUMA node during map creation (since Linux 4.15). */
    MapFlags[MapFlags["NUMA_NODE"] = 4] = "NUMA_NODE";
    /** Flags for accessing BPF object from syscall side (since Linux 4.15). */
    MapFlags[MapFlags["RDONLY"] = 8] = "RDONLY";
    /** Flags for accessing BPF object from syscall side (since Linux 4.15). */
    MapFlags[MapFlags["WRONLY"] = 16] = "WRONLY";
    /** Flag for stack_map, store build_id+offset instead of pointer. */
    MapFlags[MapFlags["STACK_BUILD_ID"] = 32] = "STACK_BUILD_ID";
    /** Zero-initialize hash function seed (since Linux 5.0). This should only be used for testing. */
    MapFlags[MapFlags["ZERO_SEED"] = 64] = "ZERO_SEED";
    /** Flags for accessing BPF object from program side (since Linux 5.2). */
    MapFlags[MapFlags["RDONLY_PROG"] = 128] = "RDONLY_PROG";
    /** Flags for accessing BPF object from program side (since Linux 5.2). */
    MapFlags[MapFlags["WRONLY_PROG"] = 256] = "WRONLY_PROG";
    /** Clone map from listener for newly accepted socket */
    MapFlags[MapFlags["CLONE"] = 512] = "CLONE";
    /** Enable memory-mapping BPF map (since Linux 5.5) */
    MapFlags[MapFlags["MMAPABLE"] = 1024] = "MMAPABLE";
    /** Share perf_event among processes (since Linux 5.10) */
    MapFlags[MapFlags["PRESERVE_ELEMS"] = 2048] = "PRESERVE_ELEMS";
    /** Create a map that is suitable to be an inner map with dynamic max entries (since Linux 5.10) */
    MapFlags[MapFlags["INNER_MAP"] = 4096] = "INNER_MAP";
})(MapFlags = exports.MapFlags || (exports.MapFlags = {}));
/** Flags for `set` operation on a map */
var MapUpdateFlags;
(function (MapUpdateFlags) {
    /** create new element or update existing */
    MapUpdateFlags[MapUpdateFlags["ANY"] = 0] = "ANY";
    /** create new element if it didn't exist */
    MapUpdateFlags[MapUpdateFlags["NOEXIST"] = 1] = "NOEXIST";
    /** update existing element */
    MapUpdateFlags[MapUpdateFlags["EXIST"] = 2] = "EXIST";
    /** spin_lock-ed operation (since Linux 5.1) */
    MapUpdateFlags[MapUpdateFlags["F_LOCK"] = 4] = "F_LOCK";
})(MapUpdateFlags = exports.MapUpdateFlags || (exports.MapUpdateFlags = {}));
/** Flags for `get` operation on a map */
var MapLookupFlags;
(function (MapLookupFlags) {
    /** spin_lock-ed operation (since Linux 5.1) */
    MapLookupFlags[MapLookupFlags["F_LOCK"] = 4] = "F_LOCK";
})(MapLookupFlags = exports.MapLookupFlags || (exports.MapLookupFlags = {}));
//# sourceMappingURL=constants.js.map