<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DASH Player – Default ABR + QoE Collector</title>

<style>
  body { margin:0; padding:20px; background:#000; color:#fff; font-family:Arial }
  #videoPlayer { width:100%; max-width:800px; background:#111; }
  .status {
    position:fixed; top:10px; left:10px; background:rgba(0,0,0,0.85);
    color:white; padding:12px; border-radius:8px; font-family:'Courier New',monospace;
    font-size:12px; z-index:10000; border:2px solid #00ff00; max-width:360px;
  }
</style>

<script src="./dash.all.min.js"></script>
</head>
<body>

<video id="videoPlayer" controls muted autoplay></video>
<div id="status" class="status"></div>

<script>
window.addEventListener('load', () => {

  const video = document.getElementById('videoPlayer');
  const statusDiv = document.getElementById('status');
  const player = dashjs.MediaPlayer().create();

  // -------------------------------------------------------
  // ENABLE DEFAULT DASH AUTO BITRATE (ABR)
  // -------------------------------------------------------
  player.updateSettings({
    streaming: { abr: { autoSwitchBitrate: true 
    ,
       initialBitrate: {
        video: 1   // in kbps, extremely low → picks lowest representation
      } }   // DEFAULT ABR
  });

  const mpdUrl = "http://10.0.0.1:8000/live/stream.mpd";
  player.initialize(video, mpdUrl, true);

  // -------------------------------------------------------
  // SESSION METRICS
  // -------------------------------------------------------
  const sessionMetrics = {
    segments: [],
    stalls: 0,
    totalStallTime: 0,
    avgRTT: 0,          // now unused but kept for JSON compatibility
    maxThroughputObserved: 0,
    qoeFinal: 0
  };

  let rttSamples = [];  // no longer used
  let qualitySwitches = 0;
  let qoeUtilitySum = 0;
  let lastQualityIndex = player.getQualityFor('video');

  // -------------------------------------------------------
  // QoE FUNCTION
  // -------------------------------------------------------
  function computeCumulativeQoE() {
    const stallPenalty = 4.3 * sessionMetrics.totalStallTime;
    const switchPenalty = 1.0 * qualitySwitches;
    return (qoeUtilitySum - stallPenalty - switchPenalty).toFixed(3);
  }

  // -------------------------------------------------------
  // BUFFER LENGTH
  // -------------------------------------------------------
  function bufferLen(){
    const b = video.buffered, t = video.currentTime;
    for(let i=0;i<b.length;i++)
      if(b.start(i)<=t && b.end(i)>=t) return b.end(i)-t;
    return 0;
  }

  // -------------------------------------------------------
  // COUNT QUALITY SWITCHES (Default ABR handles switching)
  // -------------------------------------------------------
  setInterval(() => {
    const currentQ = player.getQualityFor('video');
    if(currentQ !== lastQualityIndex){
      qualitySwitches++;
      lastQualityIndex = currentQ;
    }
  }, 500);

  // -------------------------------------------------------
  // COLLECT SEGMENT STATS + QoE UTILITY
  // -------------------------------------------------------
  setInterval(() => {
    const reps = player.getBitrateInfoListFor('video');
    const qIndex = player.getQualityFor('video');
    const rep = reps[qIndex] || reps[0];

    const bitrate = rep.bitrate / 1000;
    const utility = Math.log(bitrate);
    qoeUtilitySum += utility;

    const seg = {
      time: Number(video.currentTime.toFixed(2)),
      qualityIndex: qIndex,
      bitrateKbps: Math.round(bitrate),
      resolution: `${rep.width}x${rep.height}`,
      bufferSec: Number(bufferLen().toFixed(2)),
      throughputKbps: 0,  // removed
      rttMs: 0,
      jitterMs: 0,
      utility: utility.toFixed(4)
    };

    sessionMetrics.segments.push(seg);

  }, 1000);

  // -------------------------------------------------------
  // STALL TRACKING
  // -------------------------------------------------------
  let stallStart = null;

  video.addEventListener("waiting", () => {
    if(!stallStart){
      stallStart = performance.now();
      sessionMetrics.stalls++;
    }
  });

  video.addEventListener("playing", () => {
    if(stallStart){
      sessionMetrics.totalStallTime += (performance.now()-stallStart)/1000;
      stallStart = null;
    }
  });

  // -------------------------------------------------------
  // STATUS BAR
  // -------------------------------------------------------
  setInterval(() => {
    const reps = player.getBitrateInfoListFor('video');
    const qIndex = player.getQualityFor('video');
    const cumulativeQoE = computeCumulativeQoE();

    statusDiv.innerHTML = `
      <strong>DASH – Default ABR</strong><br>
      Bitrate: ${Math.round(reps[qIndex].bitrate/1000)} kbps<br>
      Buffer: ${bufferLen().toFixed(1)}s<br>
      Stalls: ${sessionMetrics.stalls}<br>
      Quality Switches: ${qualitySwitches}<br>
      <span style="color:#0ff">QoE (cumulative): ${cumulativeQoE}</span><br>
    `;
  }, 1500);

  // -------------------------------------------------------
  // FINAL QoE SAVE
  // -------------------------------------------------------
  video.addEventListener("ended", async () => {

    const stallPenalty = 4.3 * sessionMetrics.totalStallTime;
    const switchPenalty = 1.0 * qualitySwitches;

    sessionMetrics.qoeFinal =
      Number((qoeUtilitySum - stallPenalty - switchPenalty).toFixed(4));

    console.log("⭐⭐ FINAL QoE:", sessionMetrics.qoeFinal);

    await fetch("http://10.0.0.2:9100/save_metrics", {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(sessionMetrics)
    });

  });

});
</script>

</body>
</html>
